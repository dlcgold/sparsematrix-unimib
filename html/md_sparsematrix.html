<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sparse Matrix: sparsematrix</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sparse Matrix
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generato da Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Cerca');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Cerca');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_sparsematrix.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">sparsematrix </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
<p> author:</p><ul>
<li>| Davide Cozzi\ 829827\ <a href="#" onclick="location.href='mai'+'lto:'+'d.c'+'oz'+'zi@'+'ca'+'mpu'+'s.'+'uni'+'mi'+'b.i'+'t'; return false;">d.coz<span style="display: none;">.nosp@m.</span>zi@c<span style="display: none;">.nosp@m.</span>ampus<span style="display: none;">.nosp@m.</span>.uni<span style="display: none;">.nosp@m.</span>mib.i<span style="display: none;">.nosp@m.</span>t</a> title: | Relazione Progetto\ Programmazione C++\ <h2>Sparse Matrix </h2>
</li>
</ul>
<h1>La Struttura Dati {#la-struttura-dati .unnumbered} </h1>
<p>Ragionando sulla consegna del progetto ho concluso che il modo migliore per implementare una <b>sparse matrix</b> fosse quello di utilizzare una variante della <em>linked list</em>, dove gli elementi vengono caricati secondo l’ordine di due indici (che rappresentano la posizione di una cella in una matrice di implementazione classica). L’uso di questa variante della <em>linked list</em> permette di salvare in memoria solamente i valori indicati dall’utente (ognuno nella posizione desiderata).\ In questa implementazione ogni della <b>sparse matrix</b> contiene:</p>
<ul>
<li>un puntatore, privato, al successivo. La scelta di definire questo attributo <code>private</code> è causata dal fatto che l’utente non deve essere conscio della struttura dati in uso</li>
<li>il valore che deve essere salvato</li>
<li>i due indici mediante i quali, logicamente, accedere al valore. I due indici sono definiti <code>const</code> in quanto non modificabili dopo la creazione della cella</li>
</ul>
<p>Per questa <em>sottoclasse</em> <code>node</code> viene implementato un <em>costruttore</em> che genera un node a partire dal valore che si vuole aggiungere e dalla posizione in cui lo si vorrebbe aggiungere, senza specificare (e impostandolo di default a <code>nullptr</code>) il <code>node</code> successivo, e, ovviamente, viene implementato il <em>distruttore</em>, che si limita a settare a <code>nullptr</code> il nodo successivo (questo perché la distruzione dell’intera struttura dati viene implementata nel <em>distruttore</em> di <code><a class="el" href="classsparse__matrix.html" title="Classe sparse_matrix per matrice sparsa. ">sparse_matrix</a></code>).\ Parliamo ora della struttura dati completa, chiamata <code><a class="el" href="classsparse__matrix.html" title="Classe sparse_matrix per matrice sparsa. ">sparse_matrix</a></code>. Si hanno una serie di attributi privati necessari per il corretto funzionamento della stessa:</p>
<ul>
<li>il valore di default scelto obbligatoriamente dall’utente al monento della creazione di una matrice sparsa</li>
<li>indicazioni riguardanti il numero di righe e colonne</li>
<li>il nodo <code>head</code> che punta all’inizio della struttura dati</li>
<li>il valore di elementi effettivamente contenuti nella struttura dati</li>
</ul>
<p>Si hanno quindi diversi costruttori utili:</p>
<ul>
<li>si ha innanzitutto il costruttore base con solo l’indicazione di default, senza quindi indicazone delle dimensioni della matrice (che diventa, a livello teorico, una matrice quadrata di massima dimensione intera al quadrato)</li>
<li>il costruttore di una matrice sparsa di dimensione teorica definita dall’utente</li>
<li>costruttore copia a partire da un’altra <code><a class="el" href="classsparse__matrix.html" title="Classe sparse_matrix per matrice sparsa. ">sparse_matrix</a></code> definita sullo stesso tipo</li>
<li>costruttore copia a partire da un’altra <code><a class="el" href="classsparse__matrix.html" title="Classe sparse_matrix per matrice sparsa. ">sparse_matrix</a></code> definita su un altro tipo (con controllo del cast delegato, secondo specifiche, al compilatore)</li>
</ul>
<p>Si hanno poi, ovviamente, le implementazioni dei metodi <em>getter</em>.\ Per quanto riguarda il distruttore si ha che esso chiama un metodo pubblico <code>clear()</code> che si appoggia ad un metodo privato <code>recursive_clear(head)</code>, che, partendo appunto dal primo elemento, setta a <code>nullptr</code> i nodi raggiungibili da <code>head</code>, settando, infine, anche <code>head</code> a <code>nullptr</code>. Il metodo <code>clear()</code> è pubblico in quanto permette all’utente di eliminare una <code><a class="el" href="classsparse__matrix.html" title="Classe sparse_matrix per matrice sparsa. ">sparse_matrix</a></code> da lui creata, evitando quindi di incorrere in <em>memory leaks</em>.</p>
<h1>Funzioni Principali {#funzioni-principali .unnumbered} </h1>
<p>Ovviamente il primo discorso da affrontare è l’aggiunta di un determinato elemento in una certa posizione della nostra matrice sparsa, che viene gestito da un metodo <code>add(valore, posizione_x, posizione_y)</code>. Si hanno diverse possibili situazioni per l’inserimento di un nuovo valore:</p>
<ul>
<li>il caso “banale” è quello in cui ancora si ha una matrice sparsa senza alcun elemento, in tal caso si genera un nuovo <code>node</code> costruito sui dati in input e tale <code>node</code> diventa la nuova <code>head</code> della matrice sparsa</li>
<li>si ha poi il caso in cui la <code>head</code> attuale è posizionata in una cella logicamente successiva a quella dell’elemento che si vuole inserire. Questa situazione si puà verificare in 2 casi:<ol type="1">
<li>l’<code>head</code> attuale si trova sulla stessa riga teorica dell’elemento che si vuole aggiungere ma ad una colonna successiva</li>
<li>l’<code>head</code> attuale si trova ad una riga successiva</li>
</ol>
</li>
<li>se non si rientra nelle due casistiche precedenti si itera su tutta la matrice sparsa, fino all’avvenuta di una delle due possibili condizioni di arresto:<ol type="1">
<li>si è arrivato all’ultimo elemento della matrice sparsa (che quindi punta a <code>nullptr</code> come nodo successivo). In tal caso, se gli indici del nodo che si vuole inserire coincidono con quelli dell’ultimo elemento se ne sovrascrive il valore, ricordandosi di cancellare il nodo che si voleva inserire per evitare <em>memory leaks</em>, altrimenti lo si inserisce come ultimo elemento (il vecchio nodo “tail” ora punterà a tale elemento che a sua volta punterà a <code>nullptr</code>)</li>
<li>si sta valutando l’unico caso possibile restante, ovvero l’elmeneto che volgiamo insierire viene aggiunto in mezzo alla matrice sparsa, nella giusta posizione ordinata sui due indici. In tal caso, se gli indici del nodo che si vuole inserire coincidono con quelli dell’ultimo elemento se ne sovrascrive il valore, ricordandosi di cancellare il nodo che si voleva inserire per evitare <em>memory leaks</em>, altrimenti inserisco l’elemento che si vuole aggiungere in mezzo alla struttura dati, nel punto corretto, sistemando i puntatori ai nodi successivi dell’elemento che si vuole inserire e del suo precedente</li>
</ol>
</li>
</ul>
<p>lo stesso metodo aggiorna anche il numero massimo di righe e colonne della matrice ipotetica, cercando il massimo indice di riga e di colonna.\ L’eventuale inserimento di valori fuori indice viene gestito tramite un’eccezione <code><a class="el" href="class_index_out_of_bounds_exception.html" title="tentativo di lavorare su un cella fuori dalle dimensioni, se diciarate ">IndexOutOfBoundsException()</a></code>.\ Sempre da specifica si ha poi l’implementazione del supporto agli iteratori di tipo forward in e scrittura. Questo viene implementato con le due classi <code>iterator</code> e <code>const_iterator</code> che vengono costruti a partire da <code>node</code>. Si ha quindi la definizione dei metodi <code>begin()</code>, che restituisce un <code>iterator</code> o un <code>const_iterator</code> costruiti a partire da <code>head</code>, e <code>end()</code>, che restituisce un <code>iterator</code> o un <code>const_iterator</code> costruiti a partire da <code>nullptr</code>, per segnalare la fine della matrice sparsa.\ Un iteratore restituisce in lettura valore e posizione, in particolare <code>iterator</code> permette l’accesso in scrittura (per la modifica) del valore di una cella ma non degli indici della stessa.\ Per l’accesso in lettura dei valori della matrice si è anche implementato l’overload di <code>operator()</code>, che permette l’accesso ad un determinato valore di una cella mediante i due indici. Dato che da specifica deve avvenire la restituzione del valore di default, nel caso in cui si chieda il valore di una cella non indicizzata nella nostra matrice sparsa, si procede iterando nella matrice sparsa come nel caso della <code>add</code> fino ad ottenere una condizione d’arresto e, se si incontra il <code>node</code> con indici uguali a quelli richiesti in uscita dal ciclo se ne restituisce il valore, altrimenti si restituisce il valore di default.\ Infine viene implementata una funzione gloable <code>evaluate(sparse_matrix, predicato)</code> che conta il numero di elementi nella matrice che soddifano il predicato (considerando anche i valori di default). Si itera quindi sulla matrice sparsa contando tale numero. Infine si verifica se il valore di default lo soddisfa e, in caso positivo, si conta il numero di celle con valore di default (ovvero numero totale di celle meno il numero elementi effettivamente allocati, numero che è salvato nell’attributo <code>size</code>) e lo si somma al conteggio sopra effettuato, restituendo il risultato.\</p>
<h1>Test {#test .unnumbered} </h1>
<p>La struttura dati viene testata con il tipo primitivo <code>float</code> e ne viene testato il <em>cast</em> a <code>int</code>. Viene infine testata la matrice su un tipo custom <code>point</code>, che viene rappresentato da due coordinate. Nei vari test si verifica anche la corretta stampa mediante iteratori </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generato Gio 30 Gen 2020 10:12:56 per Sparse Matrix da
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
